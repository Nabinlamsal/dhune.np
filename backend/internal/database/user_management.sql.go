// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_management.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const approveBusinessUser = `-- name: ApproveBusinessUser :exec
UPDATE business_profiles bp
SET approval_status = 'approved',
    updated_at = now()
FROM users u
WHERE bp.user_id = u.id
  AND u.role = 'business'
  AND bp.user_id = $1
  AND bp.approval_status = 'pending'
`

// business and vendors management
func (q *Queries) ApproveBusinessUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, approveBusinessUser, userID)
	return err
}

const approveVendor = `-- name: ApproveVendor :exec
UPDATE vendor_profiles vp
SET approval_status = 'approved',
    is_active = TRUE,
    updated_at = now()
FROM users u
WHERE vp.user_id = u.id
  AND u.role = 'vendor'
  AND vp.user_id = $1
  AND vp.approval_status = 'pending'
`

func (q *Queries) ApproveVendor(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, approveVendor, userID)
	return err
}

const disableUser = `-- name: DisableUser :exec
    UPDATE users
    SET is_active = FALSE, updated_at = now()
    WHERE id = $1
`

func (q *Queries) DisableUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, disableUser, id)
	return err
}

const getUserDetail = `-- name: GetUserDetail :one
SELECT
    -- user core
    u.id,
    u.display_name,
    u.email,
    u.phone,
    u.role,
    u.is_active,
    u.is_verified,
    u.created_at,

    -- business profile (nullable)
    bp.id AS business_profile_id,
    bp.owner_name AS business_owner_name,
    bp.business_type,
    bp.registration_number AS business_registration_number,
    bp.approval_status AS business_approval_status,

    -- vendor profile (nullable)
    vp.id AS vendor_profile_id,
    vp.owner_name AS vendor_owner_name,
    vp.address AS vendor_address,
    vp.registration_number AS vendor_registration_number,
    vp.approval_status AS vendor_approval_status,
    vp.is_active AS vendor_is_active

FROM users u
         LEFT JOIN business_profiles bp
                   ON bp.user_id = u.id
                       AND u.role = 'business'
         LEFT JOIN vendor_profiles vp
                   ON vp.user_id = u.id
                       AND u.role = 'vendor'
WHERE u.id = $1
LIMIT 1
`

type GetUserDetailRow struct {
	ID                         uuid.UUID
	DisplayName                string
	Email                      string
	Phone                      string
	Role                       string
	IsActive                   bool
	IsVerified                 bool
	CreatedAt                  time.Time
	BusinessProfileID          uuid.NullUUID
	BusinessOwnerName          sql.NullString
	BusinessType               sql.NullString
	BusinessRegistrationNumber sql.NullString
	BusinessApprovalStatus     sql.NullString
	VendorProfileID            uuid.NullUUID
	VendorOwnerName            sql.NullString
	VendorAddress              sql.NullString
	VendorRegistrationNumber   sql.NullString
	VendorApprovalStatus       sql.NullString
	VendorIsActive             sql.NullBool
}

// details
func (q *Queries) GetUserDetail(ctx context.Context, id uuid.UUID) (GetUserDetailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetail, id)
	var i GetUserDetailRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Email,
		&i.Phone,
		&i.Role,
		&i.IsActive,
		&i.IsVerified,
		&i.CreatedAt,
		&i.BusinessProfileID,
		&i.BusinessOwnerName,
		&i.BusinessType,
		&i.BusinessRegistrationNumber,
		&i.BusinessApprovalStatus,
		&i.VendorProfileID,
		&i.VendorOwnerName,
		&i.VendorAddress,
		&i.VendorRegistrationNumber,
		&i.VendorApprovalStatus,
		&i.VendorIsActive,
	)
	return i, err
}

const getUserDocuments = `-- name: GetUserDocuments :many
SELECT
    id,
    document_type,
    document_url,
    verified,
    created_at
FROM documents
WHERE user_id = $1
ORDER BY created_at ASC
`

type GetUserDocumentsRow struct {
	ID           uuid.UUID
	DocumentType string
	DocumentUrl  string
	Verified     bool
	CreatedAt    time.Time
}

func (q *Queries) GetUserDocuments(ctx context.Context, userID uuid.UUID) ([]GetUserDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserDocuments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDocumentsRow
	for rows.Next() {
		var i GetUserDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentType,
			&i.DocumentUrl,
			&i.Verified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersAdminView = `-- name: GetUsersAdminView :many
SELECT
    u.id, u.display_name, u.email, u.phone, u.password_hash, u.role, u.is_verified, u.is_active, u.created_at, u.updated_at,
    bp.approval_status AS business_approval_status,
    vp.approval_status AS vendor_approval_status
FROM users u
         LEFT JOIN business_profiles bp ON bp.user_id = u.id
         LEFT JOIN vendor_profiles vp ON vp.user_id = u.id
WHERE
    (
        $3::text[] IS NULL
            OR u.role = ANY($3::text[])
        )

  AND (
    $4::text IS NULL

        OR (
        $4::text = 'pending'
            AND (
            bp.approval_status = 'pending'
                OR vp.approval_status = 'pending'
            )
        )

        OR (
        $4::text = 'rejected'
            AND (
            bp.approval_status = 'rejected'
                OR vp.approval_status = 'rejected'
            )
        )

        OR (
        $4::text = 'approved'
            AND u.is_active = TRUE
            AND (
            u.role = 'user'
                OR bp.approval_status = 'approved'
                OR vp.approval_status = 'approved'
            )
        )

        OR (
        $4::text = 'suspended'
            AND u.is_active = FALSE
        )
    )

  AND (
    $5::text IS NULL
        OR u.email ILIKE '%' || $5::text || '%'
    )
ORDER BY u.created_at DESC
LIMIT $1 OFFSET $2
`

type GetUsersAdminViewParams struct {
	Limit  int32
	Offset int32
	Roles  []string
	Status sql.NullString
	Search sql.NullString
}

type GetUsersAdminViewRow struct {
	ID                     uuid.UUID
	DisplayName            string
	Email                  string
	Phone                  string
	PasswordHash           string
	Role                   string
	IsVerified             bool
	IsActive               bool
	CreatedAt              time.Time
	UpdatedAt              time.Time
	BusinessApprovalStatus sql.NullString
	VendorApprovalStatus   sql.NullString
}

// all the users
func (q *Queries) GetUsersAdminView(ctx context.Context, arg GetUsersAdminViewParams) ([]GetUsersAdminViewRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersAdminView,
		arg.Limit,
		arg.Offset,
		pq.Array(arg.Roles),
		arg.Status,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersAdminViewRow
	for rows.Next() {
		var i GetUsersAdminViewRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Email,
			&i.Phone,
			&i.PasswordHash,
			&i.Role,
			&i.IsVerified,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BusinessApprovalStatus,
			&i.VendorApprovalStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reactivateUser = `-- name: ReactivateUser :exec
    UPDATE users
    SET is_active = TRUE, updated_at = now()
    WHERE id = $1
`

func (q *Queries) ReactivateUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, reactivateUser, id)
	return err
}

const rejectBusinessUser = `-- name: RejectBusinessUser :exec
UPDATE business_profiles bp
SET approval_status = 'rejected',
    updated_at = now()
FROM users u
WHERE bp.user_id = u.id
  AND u.role = 'business'
  AND bp.user_id = $1
  AND bp.approval_status = 'pending'
`

func (q *Queries) RejectBusinessUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, rejectBusinessUser, userID)
	return err
}

const rejectVendor = `-- name: RejectVendor :exec
UPDATE vendor_profiles vp
SET approval_status = 'rejected',
    is_active = FALSE,
    updated_at = now()
FROM users u
WHERE vp.user_id = u.id
  AND u.role = 'vendor'
  AND vp.user_id = $1
  AND vp.approval_status = 'pending'
`

func (q *Queries) RejectVendor(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, rejectVendor, userID)
	return err
}

const suspendUser = `-- name: SuspendUser :exec
    UPDATE users
    SET is_active = FALSE,
    updated_at=now()
    WHERE id=$1
`

// governance
// for approved users
func (q *Queries) SuspendUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, suspendUser, id)
	return err
}
