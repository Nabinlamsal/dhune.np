// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const cancelOrder = `-- name: CancelOrder :exec
UPDATE orders
SET order_status = 'CANCELLED',
    updated_at = now()
WHERE id = $1
  AND order_status = 'ACCEPTED'
`

// Used by: User (Cancel Before Pickup)
func (q *Queries) CancelOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, cancelOrder, id)
	return err
}

const completeOrder = `-- name: CompleteOrder :exec
UPDATE orders
SET order_status = 'COMPLETED',
    delivery_time = now(),
    updated_at = now()
WHERE id = $1
  AND order_status = 'DELIVERING'
`

// Used by: Vendor (Mark Completed)
func (q *Queries) CompleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, completeOrder, id)
	return err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    request_id,
    offer_id,
    user_id,
    vendor_id,
    final_price,
    pickup_time
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, request_id, offer_id, user_id, vendor_id, final_price, order_status, payment_status, pickup_time, delivery_time, created_at, updated_at
`

type CreateOrderParams struct {
	RequestID  uuid.UUID
	OfferID    uuid.UUID
	UserID     uuid.UUID
	VendorID   uuid.UUID
	FinalPrice string
	PickupTime sql.NullTime
}

// Used inside: Offer Acceptance Transaction (Create Order Snapshot)
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.RequestID,
		arg.OfferID,
		arg.UserID,
		arg.VendorID,
		arg.FinalPrice,
		arg.PickupTime,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.OfferID,
		&i.UserID,
		&i.VendorID,
		&i.FinalPrice,
		&i.OrderStatus,
		&i.PaymentStatus,
		&i.PickupTime,
		&i.DeliveryTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, request_id, offer_id, user_id, vendor_id, final_price, order_status, payment_status, pickup_time, delivery_time, created_at, updated_at
FROM orders
WHERE id = $1
`

// Used by: User / Vendor / Admin (Order Detail Page)
func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.OfferID,
		&i.UserID,
		&i.VendorID,
		&i.FinalPrice,
		&i.OrderStatus,
		&i.PaymentStatus,
		&i.PickupTime,
		&i.DeliveryTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderStats = `-- name: GetOrderStats :one
SELECT
    COUNT(*) AS total_orders,
    COUNT(*) FILTER (WHERE order_status = 'ACCEPTED') AS accepted_orders,
    COUNT(*) FILTER (WHERE order_status = 'PICKED_UP') AS picked_up_orders,
    COUNT(*) FILTER (WHERE order_status = 'IN_PROGRESS') AS in_progress_orders,
    COUNT(*) FILTER (WHERE order_status = 'DELIVERING') AS delivering_orders,
    COUNT(*) FILTER (WHERE order_status = 'COMPLETED') AS completed_orders,
    COUNT(*) FILTER (WHERE order_status = 'CANCELLED') AS cancelled_orders
FROM orders
`

type GetOrderStatsRow struct {
	TotalOrders      int64
	AcceptedOrders   int64
	PickedUpOrders   int64
	InProgressOrders int64
	DeliveringOrders int64
	CompletedOrders  int64
	CancelledOrders  int64
}

// Used by: Admin Dashboard (Order Stats)
func (q *Queries) GetOrderStats(ctx context.Context) (GetOrderStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrderStats)
	var i GetOrderStatsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.AcceptedOrders,
		&i.PickedUpOrders,
		&i.InProgressOrders,
		&i.DeliveringOrders,
		&i.CompletedOrders,
		&i.CancelledOrders,
	)
	return i, err
}

const listOrdersAdmin = `-- name: ListOrdersAdmin :many
SELECT id, request_id, offer_id, user_id, vendor_id, final_price, order_status, payment_status, pickup_time, delivery_time, created_at, updated_at
FROM orders
WHERE (
          $3::order_status IS NULL
              OR order_status = $3::order_status
          )
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersAdminParams struct {
	Limit  int32
	Offset int32
	Status NullOrderStatus
}

// Used by: Admin Dashboard (Global Orders with Filter)
func (q *Queries) ListOrdersAdmin(ctx context.Context, arg ListOrdersAdminParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersAdmin, arg.Limit, arg.Offset, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.OfferID,
			&i.UserID,
			&i.VendorID,
			&i.FinalPrice,
			&i.OrderStatus,
			&i.PaymentStatus,
			&i.PickupTime,
			&i.DeliveryTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT id, request_id, offer_id, user_id, vendor_id, final_price, order_status, payment_status, pickup_time, delivery_time, created_at, updated_at
FROM orders
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByUserParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

// Used by: User (My Orders)
func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.OfferID,
			&i.UserID,
			&i.VendorID,
			&i.FinalPrice,
			&i.OrderStatus,
			&i.PaymentStatus,
			&i.PickupTime,
			&i.DeliveryTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByVendor = `-- name: ListOrdersByVendor :many
SELECT id, request_id, offer_id, user_id, vendor_id, final_price, order_status, payment_status, pickup_time, delivery_time, created_at, updated_at
FROM orders
WHERE vendor_id = $1
  AND (
    $4::order_status IS NULL
        OR order_status = $4::order_status
    )
ORDER BY
    CASE
        WHEN $5 = 'pickup'
            THEN pickup_time
        END ASC,
    created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByVendorParams struct {
	VendorID uuid.UUID
	Limit    int32
	Offset   int32
	Status   NullOrderStatus
	SortBy   interface{}
}

func (q *Queries) ListOrdersByVendor(ctx context.Context, arg ListOrdersByVendorParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByVendor,
		arg.VendorID,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.OfferID,
			&i.UserID,
			&i.VendorID,
			&i.FinalPrice,
			&i.OrderStatus,
			&i.PaymentStatus,
			&i.PickupTime,
			&i.DeliveryTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOrderPaid = `-- name: MarkOrderPaid :exec
UPDATE orders
SET payment_status = 'PAID',
    updated_at = now()
WHERE id = $1
  AND payment_status = 'UNPAID'
`

// Used by: Payment Service (Mark Paid)
func (q *Queries) MarkOrderPaid(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markOrderPaid, id)
	return err
}

const markOrderRefunded = `-- name: MarkOrderRefunded :exec
UPDATE orders
SET payment_status = 'REFUNDED',
    updated_at = now()
WHERE id = $1
  AND payment_status = 'PAID'
`

// Used by: Payment Service (Refund)
func (q *Queries) MarkOrderRefunded(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markOrderRefunded, id)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET order_status = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateOrderStatusParams struct {
	ID          uuid.UUID
	OrderStatus OrderStatus
}

// Used by: Vendor (Status Progression)
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderStatus, arg.ID, arg.OrderStatus)
	return err
}
