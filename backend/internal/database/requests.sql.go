// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: requests.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const addRequestService = `-- name: AddRequestService :one
INSERT INTO request_services (
    request_id,
    category_id,
    selected_unit,
    quantity_value,
    items_json,
    description
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, request_id, category_id, selected_unit, quantity_value, items_json, description, created_at
`

type AddRequestServiceParams struct {
	RequestID     uuid.UUID
	CategoryID    uuid.UUID
	SelectedUnit  PricingUnit
	QuantityValue float64
	ItemsJson     pqtype.NullRawMessage
	Description   sql.NullString
}

// Used immediately after CreateRequest
func (q *Queries) AddRequestService(ctx context.Context, arg AddRequestServiceParams) (RequestService, error) {
	row := q.db.QueryRowContext(ctx, addRequestService,
		arg.RequestID,
		arg.CategoryID,
		arg.SelectedUnit,
		arg.QuantityValue,
		arg.ItemsJson,
		arg.Description,
	)
	var i RequestService
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.CategoryID,
		&i.SelectedUnit,
		&i.QuantityValue,
		&i.ItemsJson,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const cancelRequest = `-- name: CancelRequest :exec
UPDATE requests
SET status = 'CANCELLED',
    updated_at = now()
WHERE id = $1
  AND status = 'OPEN'
`

// Used by: User
func (q *Queries) CancelRequest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, cancelRequest, id)
	return err
}

const createRequest = `-- name: CreateRequest :one
INSERT INTO requests (
    user_id,
    pickup_address,
    pickup_time_from,
    pickup_time_to,
    payment_method,
    expires_at
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, pickup_address, pickup_time_from, pickup_time_to, payment_method, status, expires_at, created_at, updated_at
`

type CreateRequestParams struct {
	UserID         uuid.UUID
	PickupAddress  string
	PickupTimeFrom time.Time
	PickupTimeTo   time.Time
	PaymentMethod  PaymentMethod
	ExpiresAt      sql.NullTime
}

// Used by: User
func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, createRequest,
		arg.UserID,
		arg.PickupAddress,
		arg.PickupTimeFrom,
		arg.PickupTimeTo,
		arg.PaymentMethod,
		arg.ExpiresAt,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PickupAddress,
		&i.PickupTimeFrom,
		&i.PickupTimeTo,
		&i.PaymentMethod,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const expireRequests = `-- name: ExpireRequests :exec
UPDATE requests
SET status = 'EXPIRED',
    updated_at = now()
WHERE status = 'OPEN'
  AND expires_at IS NOT NULL
  AND expires_at <= now()
`

// Not exposed as public API
func (q *Queries) ExpireRequests(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, expireRequests)
	return err
}

const getRequestStats = `-- name: GetRequestStats :one
SELECT
    COUNT(*) AS total_requests,
    COUNT(*) FILTER (WHERE status = 'OPEN') AS open_requests,
    COUNT(*) FILTER (WHERE status = 'EXPIRED') AS expired_requests,
    COUNT(*) FILTER (WHERE status = 'CANCELLED') AS cancelled_requests,
    COUNT(*) FILTER (WHERE status = 'ORDER_CREATED') AS order_created_requests
FROM requests
`

type GetRequestStatsRow struct {
	TotalRequests        int64
	OpenRequests         int64
	ExpiredRequests      int64
	CancelledRequests    int64
	OrderCreatedRequests int64
}

// Used by: Admin Dashboard
func (q *Queries) GetRequestStats(ctx context.Context) (GetRequestStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getRequestStats)
	var i GetRequestStatsRow
	err := row.Scan(
		&i.TotalRequests,
		&i.OpenRequests,
		&i.ExpiredRequests,
		&i.CancelledRequests,
		&i.OrderCreatedRequests,
	)
	return i, err
}

const getRequestWithServices = `-- name: GetRequestWithServices :many
SELECT
    r.id, r.user_id, r.pickup_address, r.pickup_time_from, r.pickup_time_to, r.payment_method, r.status, r.expires_at, r.created_at, r.updated_at,
    rs.id AS service_id,
    rs.category_id,
    rs.selected_unit,
    rs.quantity_value,
    rs.items_json,
    rs.description
FROM requests r
         LEFT JOIN request_services rs ON rs.request_id = r.id
WHERE r.id = $1
`

type GetRequestWithServicesRow struct {
	ID             uuid.UUID
	UserID         uuid.UUID
	PickupAddress  string
	PickupTimeFrom time.Time
	PickupTimeTo   time.Time
	PaymentMethod  PaymentMethod
	Status         RequestsStatus
	ExpiresAt      sql.NullTime
	CreatedAt      time.Time
	UpdatedAt      time.Time
	ServiceID      uuid.NullUUID
	CategoryID     uuid.NullUUID
	SelectedUnit   NullPricingUnit
	QuantityValue  sql.NullFloat64
	ItemsJson      pqtype.NullRawMessage
	Description    sql.NullString
}

// Used by Vendor, Admin, and User
func (q *Queries) GetRequestWithServices(ctx context.Context, id uuid.UUID) ([]GetRequestWithServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRequestWithServices, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestWithServicesRow
	for rows.Next() {
		var i GetRequestWithServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PickupAddress,
			&i.PickupTimeFrom,
			&i.PickupTimeTo,
			&i.PaymentMethod,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServiceID,
			&i.CategoryID,
			&i.SelectedUnit,
			&i.QuantityValue,
			&i.ItemsJson,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMarketplaceRequests = `-- name: ListMarketplaceRequests :many
SELECT
    r.id,
    r.pickup_address,
    r.pickup_time_from,
    r.pickup_time_to,
    r.expires_at,
    r.created_at,

    COUNT(rs.id) AS service_count,
    COALESCE(SUM(rs.quantity_value), 0)::double precision AS total_quantity

FROM requests r
         LEFT JOIN request_services rs ON rs.request_id = r.id

WHERE r.status = 'OPEN'
  AND r.expires_at > now()
  AND (
    $3::uuid IS NULL
        OR rs.category_id = $3::uuid
    )

GROUP BY r.id
ORDER BY r.created_at DESC
LIMIT $1 OFFSET $2
`

type ListMarketplaceRequestsParams struct {
	Limit      int32
	Offset     int32
	CategoryID uuid.NullUUID
}

type ListMarketplaceRequestsRow struct {
	ID             uuid.UUID
	PickupAddress  string
	PickupTimeFrom time.Time
	PickupTimeTo   time.Time
	ExpiresAt      sql.NullTime
	CreatedAt      time.Time
	ServiceCount   int64
	TotalQuantity  float64
}

// Used by Vendor Dashboard
func (q *Queries) ListMarketplaceRequests(ctx context.Context, arg ListMarketplaceRequestsParams) ([]ListMarketplaceRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMarketplaceRequests, arg.Limit, arg.Offset, arg.CategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMarketplaceRequestsRow
	for rows.Next() {
		var i ListMarketplaceRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PickupAddress,
			&i.PickupTimeFrom,
			&i.PickupTimeTo,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.ServiceCount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsAdmin = `-- name: ListRequestsAdmin :many
SELECT id, user_id, pickup_address, pickup_time_from, pickup_time_to,
       payment_method, status, expires_at, created_at, updated_at
FROM requests
WHERE (
          $3::requests_status IS NULL
              OR status = $3::requests_status
          )
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRequestsAdminParams struct {
	Limit  int32
	Offset int32
	Status NullRequestsStatus
}

// Used by: Admin Panel
func (q *Queries) ListRequestsAdmin(ctx context.Context, arg ListRequestsAdminParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, listRequestsAdmin, arg.Limit, arg.Offset, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PickupAddress,
			&i.PickupTimeFrom,
			&i.PickupTimeTo,
			&i.PaymentMethod,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRequests = `-- name: ListUserRequests :many
SELECT id, user_id, pickup_address, pickup_time_from, pickup_time_to, payment_method, status, expires_at, created_at, updated_at
FROM requests
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserRequestsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

// Used by: User Dashboard
func (q *Queries) ListUserRequests(ctx context.Context, arg ListUserRequestsParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, listUserRequests, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PickupAddress,
			&i.PickupTimeFrom,
			&i.PickupTimeTo,
			&i.PaymentMethod,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setRequestOrderCreated = `-- name: SetRequestOrderCreated :exec
UPDATE requests
SET status = 'ORDER_CREATED',
    updated_at = now()
WHERE id = $1
  AND status = 'OPEN'
`

// Prevents further bidding
func (q *Queries) SetRequestOrderCreated(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setRequestOrderCreated, id)
	return err
}
